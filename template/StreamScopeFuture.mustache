/*
 * Copyright 2024 Davide Maestroni
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package sparx.concurrent;

import org.jetbrains.annotations.NotNull;
import sparx.function.Function;
import sparx.util.UncheckedException;

///////////////////////////////////////////////
// WARNING: GENERATED CODE - DO NOT MODIFY!! //
///////////////////////////////////////////////

public abstract class StreamScopeFuture<V, F extends SignalFuture<V>> implements
    StreamableFuture<V, F> {

  protected static @NotNull <V> StreamingFuture<V> pauseFuture(
      @NotNull final StreamingFuture<V> future) {
    return new PausedFuture<V>(future);
  }

  protected static void resumeFuture(@NotNull final StreamingFuture<?> pausedFuture) {
    ((PausedFuture<?>) pausedFuture).resume();
  }

  @Override
  public @NotNull <V1, F1 extends SignalFuture<V1>> F1 {{methodName}}(
      @NotNull final Function<? super F, F1> firstFunction) {
    return {{methodName}}Sequentially(firstFunction);
  }
{{#tuples}}

  @Override
  public @NotNull <{{#indexes}}V{{value}}, F{{value}} extends SignalFuture<V{{value}}>{{^last}}, {{/last}}{{#last}}> F{{value}}{{/last}}{{/indexes}} {{methodName}}(
      @NotNull final Function<? super F, F1> firstFunction,
{{#ordinals}}      @NotNull final Function<? super F{{value.prevIndex}}, F{{value.index}}> {{value.name}}Function{{^last}},{{/last}}{{#last}}) {
    final StreamScope<V{{value.index}}> scope = new StreamScope<V{{value.index}}>(FutureScope.currentScope());{{/last}}
{{/ordinals}}
    FutureScope.pushScope(scope);
    try {
      final F future = createPaused();
      final F1 first = firstFunction.apply(future);
{{#ordinals}}      final F{{value.index}} {{value.name}} = {{value.name}}Function.apply({{value.prevName}});
{{#last}}      {{value.name}}.subscribe(scope);
      resumePaused(future);
      return {{value.name}};{{/last}}
{{/ordinals}}

    } catch (final Exception e) {
      scope.onReceiverError(e);
      throw UncheckedException.throwUnchecked(e);
    } finally {
      FutureScope.popScope();
    }
  }
{{/tuples}}

  @Override
  @SuppressWarnings("unchecked")
  public @NotNull <V1, F1 extends SignalFuture<V1>> F1 {{methodName}}Sequentially(
      @NotNull final Function<? super F, F1> firstFunction) {
    final StreamScope<V1> scope = new StreamScope<V1>(FutureScope.currentScope());
    FutureScope.pushScope(scope);
    try {
      final F1 first = firstFunction.apply((F) this);
      first.subscribe(scope);
      return first;
    } catch (final Exception e) {
      scope.onReceiverError(e);
      throw UncheckedException.throwUnchecked(e);
    } finally {
      FutureScope.popScope();
    }
  }
{{#tuples}}

  @Override
  @SuppressWarnings("unchecked")
  public @NotNull <{{#indexes}}V{{value}}, F{{value}} extends SignalFuture<V{{value}}>{{^last}}, {{/last}}{{#last}}> F{{value}}{{/last}}{{/indexes}} {{methodName}}Sequentially(
      @NotNull final Function<? super F, F1> firstFunction,
{{#ordinals}}      @NotNull final Function<? super F{{value.prevIndex}}, F{{value.index}}> {{value.name}}Function{{^last}},{{/last}}{{#last}}) {
    final StreamScope<V{{value.index}}> scope = new StreamScope<V{{value.index}}>(FutureScope.currentScope());{{/last}}
{{/ordinals}}
    FutureScope.pushScope(scope);
    try {
      final F1 first = firstFunction.apply((F) this);
{{#ordinals}}      final F{{value.index}} {{value.name}} = {{value.name}}Function.apply({{value.prevName}});
{{#last}}      {{value.name}}.subscribe(scope);
      return {{value.name}};{{/last}}
{{/ordinals}}

    } catch (final Exception e) {
      scope.onReceiverError(e);
      throw UncheckedException.throwUnchecked(e);
    } finally {
      FutureScope.popScope();
    }
  }
{{/tuples}}

  protected abstract @NotNull F createPaused();

  protected abstract void resumePaused(@NotNull F pausedFuture);
}
