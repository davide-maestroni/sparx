////
// WARNING: GENERATED CODE - DO NOT MODIFY!!
////
package sparx.concurrent;

import org.jetbrains.annotations.NotNull;
import sparx.function.Function;

abstract class StreamGroupFuture<V, F extends SignalFuture<V>> implements StreamableFuture<V, F> {

  @Override
  @SuppressWarnings("unchecked")
  public @NotNull <V1, F1 extends SignalFuture<V1>> F1 {{methodName}}(
      @NotNull final Function<? super F, F1> firstFunction) {
    final StreamGroup<V1> group = new StreamGroup<V1>(FutureGroup.currentGroup());
    FutureGroup.pushGroup(group);
    try {
      final F1 first = firstFunction.apply((F) this);
      first.subscribe(group);
      return first;
    } catch (final Exception e) {
      group.onUncaughtError(e);
      throw UncheckedException.unchecked(e);
    } finally {
      FutureGroup.popGroup();
    }
  }
{{#tuples}}

  @Override
  @SuppressWarnings("unchecked")
  public @NotNull <{{#indexes}}V{{value}}, F{{value}} extends SignalFuture<V{{value}}>{{^last}}, {{/last}}{{#last}}>{{/last}}{{/indexes}}{{#indexes}}{{#last}} F{{value}}{{/last}}{{/indexes}} {{methodName}}(
      @NotNull final Function<? super F, F1> firstFunction,
{{#ordinals}}      @NotNull final Function<? super F{{value.prevIndex}}, F{{value.index}}> {{value.name}}Function{{^last}},{{/last}}{{#last}}) {
    final StreamGroup<V{{value.index}}> group = new StreamGroup<V{{value.index}}>(FutureGroup.currentGroup());{{/last}}
{{/ordinals}}
    FutureGroup.pushGroup(group);
    try {
      final F1 first = firstFunction.apply((F) this);
{{#ordinals}}      final F{{value.index}} {{value.name}} = {{value.name}}Function.apply({{value.prevName}});
{{#last}}      {{value.name}}.subscribe(group);
      return {{value.name}};{{/last}}
{{/ordinals}}

    } catch (final Exception e) {
      group.onUncaughtError(e);
      throw UncheckedException.unchecked(e);
    } finally {
      FutureGroup.popGroup();
    }
  }
{{/tuples}}
}
