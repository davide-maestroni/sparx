/*
 * Copyright 2024 Davide Maestroni
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package sparx.concurrent;

import java.util.ArrayList;
import java.util.Collection;
import org.jetbrains.annotations.NotNull;
import sparx.util.Require;
import sparx.util.UncheckedException;
import sparx.util.function.Function;
import sparx.util.function.Supplier;

///////////////////////////////////////////////
// WARNING: GENERATED CODE - DO NOT MODIFY!!
// - templating engine: {{engine}}
// - template path: {{path}}
///////////////////////////////////////////////

abstract class GeneratorScopeFuture<V> extends ReadOnlyFuture<V> implements GeneratingFuture<V> {

  GeneratorScopeFuture(@NotNull final StreamingFuture<V> future) {
    super(future);
  }

  @Override
  public @NotNull Subscription subscribe() {
    return subscribe(null, null, null, null);
  }

  public @NotNull <V1, F1 extends SignalFuture<V1>> GeneratingFuture<V1> {{methodName}}Pulling(
      @NotNull final Function<? super StreamingFuture<V>, F1> firstFunction) {
    final StreamScope<V1> scope = new StreamScope<V1>(FutureScope.currentScope());
    FutureScope.pushScope(scope);
    try {
      final VarFuture<V> input = VarFuture.create();
      final F1 output = input.{{methodName}}Sequentially(firstFunction);
      final GeneratorStreamReceiver<V1> receiver = new GeneratorStreamReceiver<V1>(input, output);
      final GeneratingFuture<V1> future = createGeneratingFuture(receiver);
      future.subscribe(scope);
      return future;
    } catch (final Exception e) {
      scope.onReceiverError(e);
      throw UncheckedException.throwUnchecked(e);
    } finally {
      FutureScope.popScope();
    }
  }
{{#tuples}}

  public @NotNull <{{#indexes}}V{{value}}, F{{value}} extends SignalFuture<V{{value}}>{{^last}}, {{/last}}{{#last}}> GeneratingFuture<V{{value}}>{{/last}}{{/indexes}} {{methodName}}Pulling(
      @NotNull final Function<? super StreamingFuture<V>, F1> firstFunction,
{{#ordinals}}      @NotNull final Function<? super F{{value.prevIndex}}, F{{value.index}}> {{value.name}}Function{{^last}},{{/last}}{{#last}}) {
    final StreamScope<V{{value.index}}> scope = new StreamScope<V{{value.index}}>(FutureScope.currentScope());{{/last}}
{{/ordinals}}
    FutureScope.pushScope(scope);
    try {
      final VarFuture<V> input = VarFuture.create();
{{#ordinals}}{{#last}}      final F{{value.index}} output = input.{{methodName}}Sequentially({{/last}}{{/ordinals}}
{{#ordinals}}
          {{value.prevName}}Function,{{#last}}

          {{value.name}}Function{{/last}}
{{/ordinals}}
      );
{{#ordinals}}{{#last}}      final GeneratorStreamReceiver<V{{value.index}}> receiver = new GeneratorStreamReceiver<V{{value.index}}>(input, output);
      final GeneratingFuture<V{{value.index}}> future = createGeneratingFuture(receiver);
{{/last}}{{/ordinals}}
      future.subscribe(scope);
      return future;
    } catch (final Exception e) {
      scope.onReceiverError(e);
      throw UncheckedException.throwUnchecked(e);
    } finally {
      FutureScope.popScope();
    }
  }
{{/tuples}}

  abstract @NotNull <U> GeneratingFuture<U> createGeneratingFuture(
      @NotNull Supplier<? extends SignalFuture<U>> supplier);

  private class GeneratorStreamReceiver<U> implements Receiver<U>, Supplier<SignalFuture<U>> {

    private final VarFuture<V> input;
    private final SignalFuture<U> output;
    private final ArrayList<U> pendingValues = new ArrayList<U>();
    private final Receiver<V> receiver = new Receiver<V>() {
      @Override
      public void close() {
        input.close();
      }

      @Override
      public boolean fail(@NotNull final Exception error) {
        return input.fail(error);
      }

      @Override
      public void set(final V value) {
        unsubscribe(this);
        input.set(value);
      }

      @Override
      public void setBulk(@NotNull final Collection<V> values) {
        unsubscribe(this);
        input.setBulk(values);
      }
    };

    private VarFuture<U> future;
    private volatile Supplier<SignalFuture<U>> status = new RunningStatus();

    private GeneratorStreamReceiver(@NotNull final VarFuture<V> input,
        @NotNull final SignalFuture<U> output) {
      this.input = input;
      this.output = Require.notNull(output, "output");
    }

    @Override
    public void close() {
      final ArrayList<U> pendingValues = this.pendingValues;
      synchronized (pendingValues) {
        status = new ClosedStatus();
        final VarFuture<U> future = this.future;
        if (future != null) {
          future.setBulk(pendingValues);
          future.close();
          pendingValues.clear();
        }
      }
    }

    @Override
    public boolean fail(@NotNull final Exception error) {
      final ArrayList<U> pendingValues = this.pendingValues;
      synchronized (pendingValues) {
        status = new FailedStatus(error);
        final VarFuture<U> future = this.future;
        if (future != null) {
          future.setBulk(pendingValues);
          future.fail(error);
          pendingValues.clear();
        }
      }
      return true;
    }

    @Override
    public SignalFuture<U> get() throws Exception {
      return status.get();
    }

    @Override
    public void set(final U value) {
      unsubscribe(input);
      final VarFuture<U> future = this.future;
      final ArrayList<U> pendingValues = this.pendingValues;
      synchronized (pendingValues) {
        if (pendingValues.isEmpty()) {
          if (future != null) {
            future.set(value);
            future.close();
          } else {
            pendingValues.add(value);
          }
        } else {
          pendingValues.add(value);
          if (future != null) {
            future.setBulk(pendingValues);
            future.close();
            pendingValues.clear();
          }
        }
      }
    }

    @Override
    public void setBulk(@NotNull final Collection<U> values) {
      unsubscribe(input);
      final VarFuture<U> future = this.future;
      final ArrayList<U> pendingValues = this.pendingValues;
      synchronized (pendingValues) {
        if (pendingValues.isEmpty()) {
          if (future != null) {
            future.setBulk(values);
            future.close();
          } else {
            pendingValues.addAll(values);
          }
        } else {
          pendingValues.addAll(values);
          if (future != null) {
            future.setBulk(pendingValues);
            future.close();
            pendingValues.clear();
          }
        }
      }
    }

    private class ClosedStatus implements Supplier<SignalFuture<U>> {

      @Override
      public SignalFuture<U> get() {
        final ArrayList<U> pendingValues = GeneratorStreamReceiver.this.pendingValues;
        synchronized (pendingValues) {
          if (!pendingValues.isEmpty()) {
            final ValFuture<U> future = ValFuture.ofBulk(pendingValues);
            pendingValues.clear();
            return future;
          }
        }
        return null;
      }
    }

    private class FailedStatus implements Supplier<SignalFuture<U>> {

      private final Exception failureException;

      private FailedStatus(@NotNull final Exception error) {
        failureException = error;
      }

      @Override
      public SignalFuture<U> get() {
        final ArrayList<U> pendingValues = GeneratorStreamReceiver.this.pendingValues;
        synchronized (pendingValues) {
          if (!pendingValues.isEmpty()) {
            final VarFuture<U> future = VarFuture.create();
            future.setBulk(pendingValues);
            future.fail(failureException);
            pendingValues.clear();
            return future;
          }
        }
        return ValFuture.ofFailure(failureException);
      }
    }

    private class RunningStatus implements Supplier<SignalFuture<U>> {

      @Override
      public SignalFuture<U> get() {
        final ArrayList<U> pendingValues = GeneratorStreamReceiver.this.pendingValues;
        synchronized (pendingValues) {
          if (!pendingValues.isEmpty()) {
            final ValFuture<U> future = ValFuture.ofBulk(pendingValues);
            pendingValues.clear();
            return future;
          } else {
            future = VarFuture.create();
          }
        }
        output.subscribe(GeneratorStreamReceiver.this);
        subscribeNext(receiver);
        return future;
      }
    }
  }
}
